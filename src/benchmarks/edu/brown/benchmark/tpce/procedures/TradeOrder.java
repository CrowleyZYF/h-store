/***************************************************************************
 *  Copyright (C) 2009 by H-Store Project                                  *
 *  Brown University                                                       *
 *  Massachusetts Institute of Technology                                  *
 *  Yale University                                                        *
 *                                                                         *
 *  Original Version:                                                      *
 *  Zhe Zhang (zhe@cs.brown.edu)                                           *
 *  http://www.cs.brown.edu/~zhe/                                          *
 *                                                                         *
 *  Modifications by:                                                      *
 *  Andy Pavlo (pavlo@cs.brown.edu)                                        *
 *  http://www.cs.brown.edu/~pavlo/                                        *
 *                                                                         *
 *  Modifications by:                                                      *
 *  Alex Kalinin (akalinin@cs.brown.edu)                                   *
 *  http://www.cs.brown.edu/~akalinin/                                     *
 *                                                                         *
 *  Permission is hereby granted, free of charge, to any person obtaining  *
 *  a copy of this software and associated documentation files (the        *
 *  "Software"), to deal in the Software without restriction, including    *
 *  without limitation the rights to use, copy, modify, merge, publish,    *
 *  distribute, sublicense, and/or sell copies of the Software, and to     *
 *  permit persons to whom the Software is furnished to do so, subject to  *
 *  the following conditions:                                              *
 *                                                                         *
 *  The above copyright notice and this permission notice shall be         *
 *  included in all copies or substantial portions of the Software.        *
 *                                                                         *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,        *
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     *
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. *
 *  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR      *
 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,  *
 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  *
 *  OTHER DEALINGS IN THE SOFTWARE.                                        *
 ***************************************************************************/
package edu.brown.benchmark.tpce.procedures;

import org.voltdb.SQLStmt;
import org.voltdb.VoltProcedure;
import org.voltdb.VoltTable;
import org.voltdb.VoltTableRow;
import org.voltdb.VoltType;
import org.voltdb.types.TimestampType;

import edu.brown.benchmark.tpce.TPCEConstants;

/**
 * Trade-Order Transaction <br/>
 * TPC-E Section 3.3.1
 *
 * H-Store exceptions:
 *   1) getHoldingAssets cannot return SUM(HS_QTY * LT_PRICE), but only HS_QTY * LT_PRICE; so we do the SUM() manually in the frame
 *   2) getTaxrate is modified from the specification to use a join instead of a "in" (sub-queries are not supported in H-Store)
 *   3) send_to_market is quirky: we piggyback it with the result back to the client
 *   4) trade_id is not generated here because it is hard to coordinate its uniqueness; it is generated by the client instead and passed here
 *      as a parameter; it is returned, though, with the result
 *   5) Some values retrieved from tables are not used, but required to be passed between frames. Those are "unused values" as in Java.
 *
 */

 /**
  * Trade-Order事务
  * 输入参数：
  * acct_id: 从现在available的customer里，根据customer tier选出一个customer，然后在该customer所拥有的account里随机挑出一个账号
  * co_name: 事务交易的时候可以通过两种方式来限定股票，一种是给出股票的symbol，还有一种是给出股票的所属公司名称和股票类型（普通股还是优先股）。只能使用一种，另一种必须为空字符串
  * exec_f_name: 交易执行者的名，不一定是账户所有者，可能是有相关操作权的用户
  * exec_l_name: 交易执行者的姓
  * exec_tax_id: 交易执行者的税务id
  * is_lifo: 如果设置为TRUE的话，交易对于持有股的处理顺序是先旧的，后新的。如果是FALSE的话，处理顺序就是反过来的
  * issue: 股票类型
  * requested_price: 如果是限购类型，那么就是触发交易的价格。如果是市场价购买，那么初始值为undefined，在frame3的时候获取价格
  * roll_it_back: 是否会进行rollback的FLAG
  * st_pending_id: pending状态的id
  * st_submitted_id: submit的状态id
  * symbol: 股票代号
  * trade_qty: 交易数量
  * trade_type_id: 交易类型ID
  * type_is_margin: 交易类型是否为保证金形式
  * 输出参数：
  * buy_value: 购买总价，如果是新股，那么为0
  * sell_value: 卖出总价，如果是新股，那么为0
  * status: 状态
  * tax_amount: 估计的税，如果没有赢利，那么为0
  * trade_id: 事务ID
  */
public class TradeOrder extends VoltProcedure {
    private final VoltTable trade_order_ret_template = new VoltTable(
            new VoltTable.ColumnInfo("buy_value", VoltType.FLOAT),
            new VoltTable.ColumnInfo("sell_value", VoltType.FLOAT),
            new VoltTable.ColumnInfo("tax_amount", VoltType.FLOAT),
            new VoltTable.ColumnInfo("trade_id", VoltType.BIGINT),
            new VoltTable.ColumnInfo("eAction", VoltType.INTEGER)
    );

    public final SQLStmt getAccount1 = new SQLStmt("select CA_NAME, CA_B_ID, CA_C_ID, CA_TAX_ST from CUSTOMER_ACCOUNT where CA_ID = ?");

    public final SQLStmt getCustomer = new SQLStmt("select C_F_NAME, C_L_NAME, C_TIER, C_TAX_ID from CUSTOMER where C_ID = ?");

    public final SQLStmt getBroker = new SQLStmt("select B_NAME from BROKER where B_ID = ?");

    public final SQLStmt getACL = new SQLStmt("select AP_ACL from ACCOUNT_PERMISSION where AP_CA_ID = ? and AP_F_NAME = ? and AP_L_NAME = ? and AP_TAX_ID = ?");

    public final SQLStmt getCompany = new SQLStmt("select CO_ID from COMPANY where CO_NAME = ?");

    public final SQLStmt getSecurity1 = new SQLStmt("select S_EX_ID, S_NAME, S_SYMB from SECURITY where S_CO_ID = ? and S_ISSUE = ?");

    public final SQLStmt getSecurity2 = new SQLStmt("select S_CO_ID, S_EX_ID, S_NAME from SECURITY where S_SYMB = ?");

    public final SQLStmt getCompany2 = new SQLStmt("select CO_NAME from COMPANY where CO_ID = ?");

    public final SQLStmt getLastTrade = new SQLStmt("select LT_PRICE from LAST_TRADE where LT_S_SYMB = ?");

    public final SQLStmt getTradeType = new SQLStmt("select TT_IS_MRKT, TT_IS_SELL from TRADE_TYPE where TT_ID = ?");

    public final SQLStmt getHoldingSummmary = new SQLStmt("select HS_QTY from HOLDING_SUMMARY where HS_CA_ID = ? and HS_S_SYMB = ?");

    public final SQLStmt getHoldingDesc = new SQLStmt("select H_QTY, H_PRICE from HOLDING where H_CA_ID = ? and H_S_SYMB = ? order by H_DTS desc");

    public final SQLStmt getHoldingAsc = new SQLStmt("select H_QTY, H_PRICE from HOLDING where H_CA_ID = ? and H_S_SYMB = ? order by H_DTS asc");

    public final SQLStmt getTaxrate = new SQLStmt("select sum(TX_RATE) from TAXRATE, CUSTOMER_TAXRATE where TX_ID = CX_TX_ID and CX_C_ID = ?");

    public final SQLStmt getCommissionRate = new SQLStmt("select CR_RATE from COMMISSION_RATE where CR_C_TIER = ? and CR_TT_ID = ? and CR_EX_ID = ? and CR_FROM_QTY <= ? and CR_TO_QTY >= ?");

    public final SQLStmt getCharge = new SQLStmt("select CH_CHRG from CHARGE where CH_C_TIER = ? and CH_TT_ID = ?");

    public final SQLStmt getAccount2 = new SQLStmt("select CA_BAL from CUSTOMER_ACCOUNT where CA_ID = ?");

    public final SQLStmt getHoldingAssets = new SQLStmt(
            "select HS_QTY * LT_PRICE from HOLDING_SUMMARY, LAST_TRADE where HS_CA_ID = ? and LT_S_SYMB = HS_S_SYMB");

    public final SQLStmt insertTrade = new SQLStmt("insert into TRADE(T_ID, T_DTS, T_ST_ID, T_TT_ID, T_IS_CASH, T_S_SYMB, T_QTY, "
            + "T_BID_PRICE, T_CA_ID, T_EXEC_NAME, T_TRADE_PRICE, T_CHRG, T_COMM, T_TAX, T_LIFO) " + "values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");

    public final SQLStmt insertTradeRequest = new SQLStmt("insert into TRADE_REQUEST (TR_T_ID, TR_TT_ID, TR_S_SYMB, TR_QTY, TR_BID_PRICE, TR_CA_ID) " + "values (?, ?, ?, ?, ?, ?)");

    public final SQLStmt insertTradeHistory = new SQLStmt("insert into TRADE_HISTORY(TH_T_ID, TH_DTS, TH_ST_ID) values (?, ?, ?)");

    public VoltTable[] run(double requested_price, long acct_id, long is_lifo, long roll_it_back, long trade_qty, long type_is_margin, String co_name, String exec_f_name, String exec_l_name,
            String exec_tax_id, String issue, String st_pending_id, String st_submitted_id, String symbol, String trade_type_id, long trade_id) throws VoltAbortException {

        // frame 1: account info
        // 获取顾客，顾客账号，经纪人的相关信息
        voltQueueSQL(getAccount1, acct_id);
        VoltTable acc_info = voltExecuteSQL()[0];

        assert acc_info.getRowCount() == 1;

        VoltTableRow acc_info_row = acc_info.fetchRow(0);
        String acct_name = acc_info_row.getString("CA_NAME");//账户名称
        long broker_id = acc_info_row.getLong("CA_B_ID");//经纪人id
        long cust_id = acc_info_row.getLong("CA_C_ID");//顾客id
        int tax_status = (int)acc_info_row.getLong("CA_TAX_ST");//税状态

        voltQueueSQL(getCustomer, cust_id);
        voltQueueSQL(getBroker, broker_id);
        VoltTable[] cust_broker_info = voltExecuteSQL();

        assert cust_broker_info[0].getRowCount() == 1;
        assert cust_broker_info[1].getRowCount() == 1;
        VoltTableRow cust_row = cust_broker_info[0].fetchRow(0);
        VoltTableRow broker_row = cust_broker_info[1].fetchRow(0);

        String cust_f_name = cust_row.getString("C_F_NAME");//顾客名
        String cust_l_name = cust_row.getString("C_L_NAME");//顾客姓
        int cust_tier = (int)cust_row.getLong("C_TIER");//顾客等级
        String tax_id = cust_row.getString("C_TAX_ID");//税ID
        String broker_name = broker_row.getString("B_NAME");//经纪人名称

        // frame 2: check if the account executor has rights to do that
        // 如果执行者的姓、名、税ID和顾客的姓、名的税ID不一致的时候，则查看执行者对该账户是否有权限
        if (!exec_l_name.equals(cust_l_name) || !exec_f_name.equals(cust_f_name) || !exec_tax_id.equals(tax_id)) {
            voltQueueSQL(getACL, acct_id, exec_f_name, exec_l_name, exec_tax_id);
            VoltTable acl = voltExecuteSQL()[0];

            assert acl.getRowCount() == 1;
            //如果返回的access control list是null的话，那么就代表了这个执行者并咩有这个权限
            if (acl.fetchRow(0).get(0) == null) {
                throw new VoltAbortException("ACL for a Trade-Order transaction is NULL");
            }
        }

        // frame 3: estimating overall financial impact
        // 模拟估计整个交易对于市场的影响
        long co_id;
        String exch_id;
        String s_name;

        // 获取该股票的相关信息，需要获取公司ID，交易所ID，股票名称，股票代号
        if (symbol.equals("")) {
            voltQueueSQL(getCompany, co_name);
            VoltTable comp = voltExecuteSQL()[0];

            assert comp.getRowCount() == 1;
            co_id = comp.fetchRow(0).getLong("CO_ID");

            voltQueueSQL(getSecurity1, co_id, issue);
            VoltTable sec = voltExecuteSQL()[0];

            assert sec.getRowCount() == 1;
            VoltTableRow sec_row = sec.fetchRow(0);

            exch_id = sec_row.getString("S_EX_ID");
            s_name = sec_row.getString("S_NAME");
            symbol = sec_row.getString("S_SYMB");
        }
        else {
            voltQueueSQL(getSecurity2, symbol);
            VoltTable sec = voltExecuteSQL()[0];

            assert sec.getRowCount() == 1;
            VoltTableRow sec_row = sec.fetchRow(0);

            co_id = sec_row.getLong("S_CO_ID");
            exch_id = sec_row.getString("S_EX_ID");
            s_name = sec_row.getString("S_NAME");

            voltQueueSQL(getCompany2, co_id);
            VoltTable comp = voltExecuteSQL()[0];

            assert comp.getRowCount() == 1;
            co_name = comp.fetchRow(0).getString("CO_NAME");
        }

        voltQueueSQL(getLastTrade, symbol);
        voltQueueSQL(getTradeType, trade_type_id);
        voltQueueSQL(getHoldingSummmary, acct_id, symbol);
        VoltTable[] res = voltExecuteSQL();

        assert res[0].getRowCount() == 1;
        assert res[1].getRowCount() == 1;
        //获取当前市场价格以及交易属性
        double market_price = res[0].fetchRow(0).getDouble("LT_PRICE");

        VoltTableRow tt_row = res[1].fetchRow(0);
        int type_is_market = (int)tt_row.getLong("TT_IS_MRKT");
        int type_is_sell = (int)tt_row.getLong("TT_IS_SELL");

        // for market orders price is determined by the last trade
        // 如果是市场价购买，那么将价格设置为当前价格
        if (type_is_market == 1) {
            requested_price = market_price;
        }

        int hs_qty = 0;
        if (res[2].getRowCount() == 1) {
            hs_qty = (int)res[2].fetchRow(0).getLong("HS_QTY");
        }

        double buy_value = 0;
        double sell_value = 0;
        long needed_qty = trade_qty;

        // estimate impact on short and long positions
        // 如果是卖出，则对持有该股的多头进行财务影响预估
        if (type_is_sell == 1) {
            if (hs_qty > 0) {//持有该股
                if (is_lifo == 1) {
                    voltQueueSQL(getHoldingDesc, acct_id, symbol);
                }
                else {
                    voltQueueSQL(getHoldingAsc, acct_id, symbol);
                }

                VoltTable hold_list = voltExecuteSQL()[0];

                for (int i = 0; i < hold_list.getRowCount() && needed_qty != 0; i++) {
                    VoltTableRow hold = hold_list.fetchRow(i);
                    int hold_qty = (int)hold.getLong("H_QTY");
                    double hold_price = hold.getDouble("H_PRICE");
                    //如果持有股中的第一条记录的数量已经大于卖出股数，那么就处理这一个记录就够了
                    if (hold_qty > needed_qty) {
                        buy_value += needed_qty * hold_price;//这些股花了多少钱买的
                        sell_value += needed_qty * requested_price;//这些股准备多少钱卖掉
                        needed_qty = 0;
                    }
                    else {
                        buy_value += hold_qty * hold_price;
                        sell_value += hold_qty * requested_price;
                        needed_qty = needed_qty - hold_qty;
                    }
                }
            }
        }
        else { // buy transaction
            if (hs_qty < 0) {//买的话，判断之前持有的股票是不是负数，如果是负数的话，需要减去相关记录或者进行调整
                if (is_lifo == 1) {
                    voltQueueSQL(getHoldingDesc, acct_id, symbol);
                }
                else {
                    voltQueueSQL(getHoldingAsc, acct_id, symbol);
                }

                VoltTable hold_list = voltExecuteSQL()[0];

                for (int i = 0; i < hold_list.getRowCount() && needed_qty != 0; i++) {
                    VoltTableRow hold = hold_list.fetchRow(i);
                    int hold_qty = (int)hold.getLong("H_QTY");
                    double hold_price = hold.getDouble("H_PRICE");

                    if (hold_qty + needed_qty < 0) {
                        sell_value += needed_qty * hold_price;
                        buy_value += needed_qty * requested_price;
                        needed_qty = 0;
                    }
                    else {
                        hold_qty = -hold_qty;
                        sell_value += hold_qty * hold_price;
                        buy_value += hold_qty * requested_price;
                        needed_qty = needed_qty - hold_qty;
                    }
                }
            }
        }

        // estimate taxes
        double tax_amount = 0;
        // 如果卖出的价格大于买入的价格，那么就说明赚了，就要交税
        // 税的状态有3种，0代表不用交税，1代表需要交税同时必须扣缴捐税的withholding，2代表要交税，但不一定要扣缴捐税的
        if (sell_value > buy_value && (tax_status == 1 || tax_status == 2)) {
            voltQueueSQL(getTaxrate, cust_id);
            VoltTable tr = voltExecuteSQL()[0];

            assert tr.getRowCount() == 1;
            double tax_rates = tr.fetchRow(0).getDouble(0);
            tax_amount = (sell_value - buy_value) * tax_rates;
        }

        // administrative fees
        voltQueueSQL(getCommissionRate, cust_tier, trade_type_id, exch_id, trade_qty, trade_qty);
        voltQueueSQL(getCharge, cust_tier, trade_type_id);
        VoltTable[] comm_chrg = voltExecuteSQL();

        assert comm_chrg[0].getRowCount() == 1;
        assert comm_chrg[1].getRowCount() == 1;

        double comm_rate = comm_chrg[0].fetchRow(0).getDouble("CR_RATE");
        double charge_amount = comm_chrg[1].fetchRow(0).getDouble("CH_CHRG");

        // estimate customer's assets if the trade is a margin one
        double cust_assets = 0;
        if (type_is_margin == 1) {
            voltQueueSQL(getAccount2, acct_id);
            voltQueueSQL(getHoldingAssets, acct_id);

            VoltTable[] assets = voltExecuteSQL();
            VoltTable holds = assets[1];

            assert assets[0].getRowCount() == 1;
            double acct_bal = assets[0].fetchRow(0).getDouble("CA_BAL");//账户余额

            if (holds.getRowCount() == 0) {//如果现在用户没有持有任何股票，那么用户资产就是账户余额，不然的话就全部存起来
                cust_assets = acct_bal;
            }
            else {
                // H-Store does not support SUM(X * Y), so we make it manually
                double hold_assets = 0;
                for (int i = 0; i < holds.getRowCount(); i++) {
                    hold_assets += holds.fetchRow(i).getDouble(0);
                }

                cust_assets = hold_assets + acct_bal;
            }
        }

        // trade status
        // 如果是市场交易，那么就立即执行，不然的话就是pending的状态
        String status_id = (type_is_market == 1) ? st_submitted_id : st_pending_id;

        // frame 4: inserting the trade
        double comm_amount = (comm_rate / 100) * trade_qty * requested_price;//交易费用
        String exec_name = exec_f_name + " " + exec_l_name;
        int is_cash = (type_is_margin == 1) ? 0 : 1;
        TimestampType now_dts = new TimestampType();

        voltQueueSQL(insertTrade, trade_id, now_dts, status_id, trade_type_id, is_cash,
                symbol, trade_qty, requested_price, acct_id, exec_name, null, charge_amount,
                comm_amount, 0, is_lifo);

        if (type_is_market == 0) {
            voltQueueSQL(insertTradeRequest, trade_id, trade_type_id, symbol, trade_qty,
                    requested_price, acct_id);
        }

        voltQueueSQL(insertTradeHistory, trade_id, now_dts, status_id);

        voltExecuteSQL();

        // frame 5: intentional roll-back
        if (roll_it_back == 1) {
            throw new VoltAbortException("Intentional roll-back of a Trade-Order");
        }

        // frame 6: commit (nothing to do) and send_to_market, which is returned with the result
        int eAction = (type_is_market == 1) ? TPCEConstants.eMEEProcessOrder : TPCEConstants.eMEESetLimitOrderTrigger;

        VoltTable ret_values = trade_order_ret_template.clone(128);
        ret_values.addRow(buy_value, sell_value, tax_amount, trade_id, eAction);

        return new VoltTable[] {ret_values};
    }
}
